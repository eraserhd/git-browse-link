#!/bin/sh
#
# Syntax is `git browse-link FILE [POSITION]`
#

PREFERRED_REMOTES='upstream origin'

reachableFromRemote() {
    gxi -e '
        (import :std/misc/ports
                :std/misc/process)

        (def (reachable? from to)
          (string=? (run-process ["git" "merge-base" from to])
                    (run-process ["git" "rev-parse" "--verify" from])))

        (def (remote-branches remote)
          (run-process ["git" "for-each-ref" "--format=%(refname)"
                        (string-append "refs/remotes/" remote)]
                       coprocess: read-all-as-lines))

        (def (reachable-from-remote? head remote)
          (call/cc (lambda (cont)
                     (for-each (lambda (branch)
                                 (if (reachable? head branch)
                                   (cont #t)))
                               (remote-branches remote))
                     #f)))

        (if (not (reachable-from-remote? "'$1'" "'$2'"))
          (exit 1))
    '
}

bestRemote() {
    # $1=head
    for bestRemote_remote in $PREFERRED_REMOTES $(git remote); do
        if reachableFromRemote "$1" "$bestRemote_remote"; then
            printf %s\\n "$bestRemote_remote"
            return 0
        fi
    done
    return 1
}

originUrl() {
    originUrl_head=$(git rev-parse HEAD)
    originUrl_bestRemote=$(bestRemote "$originUrl_head")
    if [ -z "$originUrl_bestRemote" ]; then
        printf 'Cannot find a reachable remote.\n' >&2
        exit 2
    fi
    git remote get-url "$originUrl_bestRemote"
}

makeBrowseUrlPrefix() {
    gxi -e '
        (import :std/format
                :std/misc/string
                :std/pregexp
                :std/sugar)

        (def (make-browse-url-prefix origin-url)
          (def github (match <> ([_ owner repo] (format "https://github.com/~a/~a/blob" owner repo))))
          (cond
            ((pregexp-match "^git@github\\.com:([^/]*)/([^/]*?)(?:\\.git)?$" origin-url)     => github)
            ((pregexp-match "^https://github\\.com/([^/]*)/([^/]*?)(?:\\.git)?$" origin-url) => github)
            (else
             origin-url)))

        (displayln (make-browse-url-prefix "'$1'"))
    '
}

makePositionAnchor() {
    gxi -e '
      (import :std/format
              :std/pregexp)
      (def (make-position-anchor position)
        (match (pregexp-match "^(\\d+)\\.\\d+,(\\d+)\\." position)
          ([_ (apply string->number line1) (apply string->number line2)]
           (cond
             ((=  line1 line2) (format "#L~a" line1))
             ((<= line1 line2) (format "#L~a-L~a" line1 line2))
             (else             (format "#L~a-L~a" line2 line1))))
          (#f "")))

      (displayln (make-position-anchor "'$1'"))
    '
}

makeGitBrowseLink() {
    makeGitBrowseLink_head="$(git rev-parse HEAD)"
    makeGitBrowseLink_prefix="$(makeBrowseUrlPrefix "$(originUrl)")"
    if [ -z "$makeGitBrowseLink_prefix" ]; then
        printf 'git-browse-link: cannot find a remote with commit %s\n' "$makeGitBrowseLink_head" >&2
        return 3
    fi
    printf %s/%s/%s%s\\n \
        "$makeGitBrowseLink_prefix" \
        "$makeGitBrowseLink_head" \
        "$(git ls-files --full-name "$FILENAME")" \
        "$(makePositionAnchor "$POSITION")"
}

FILENAME="$1"
POSITION="$2"
if [ ! -e "$FILENAME" ]; then
    printf 'git-browse-link: %s: No such file or directory\n' "$FILENAME" >&2
    return 1
fi
if [ -d "$FILENAME" ]; then
    printf 'git-browse-link: %s is a directory\n' "$FILENAME" >&2
    return 1
fi

cd "$(dirname "$FILENAME")" || exit $?
FILENAME="$(basename "$FILENAME")"

makeGitBrowseLink
exit $?
